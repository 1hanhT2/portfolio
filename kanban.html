<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kanban Board with Timers</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles/main.css">
    <style>
        /* --- Basic Styles (mostly unchanged) --- */
        :root {
            /* Bridge this page to the site theme */
            --color-background: var(--bg);
            --color-text: var(--text);
            --color-primary: var(--accent);
            --color-secondary: #50e3c2;
            --color-accent: #f5a623;
            --color-danger: #d0021b;
            --color-white: #ffffff;
            --color-border: #dee2e6;
            --color-timer: #6c757d; /* Color for timer text */

            --priority-low: #7fbc8c;
            --priority-medium: #f7b731;
            --priority-high: #e57373;
        }

        body {
            font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
            background-color: var(--bg);
            margin: 0;
            padding: 0;
            color: var(--color-text);
            line-height: 1.6;
        }

        h1 { text-align: center; color: var(--color-primary); margin-bottom: 20px; }

        .add-task-form {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 30px;
            padding: 15px;
            background-color: var(--color-white);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
        }

        #new-task-input {
            padding: 10px 15px;
            border: 1px solid var(--color-border);
            border-radius: 5px;
            font-size: 1rem;
            flex-grow: 1;
            min-width: 250px;
        }

         #priority-select {
            padding: 10px 10px;
            border: 1px solid var(--color-border);
            border-radius: 5px;
            font-size: 0.9rem;
            background-color: var(--color-white);
            cursor: pointer;
        }

        #add-task-button {
            padding: 10px 20px;
            background-color: var(--color-primary);
            color: var(--color-white);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease;
        }

        #add-task-button:hover { background-color: #357abd; }

        .kanban-board {
            display: flex;
            justify-content: space-around;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .column {
            background-color: #e9ecef;
            border-radius: 8px;
            padding: 15px;
            width: 320px;
            min-height: 450px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
            transition: background-color 0.3s ease;
        }

        .column-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--color-border);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        .column-header h2 { margin: 0; color: var(--color-text); font-size: 1.1rem; font-weight: 600; }

        .task-count {
            background-color: var(--color-primary);
            color: var(--color-white);
            border-radius: 10px;
            padding: 2px 8px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .tasks {
            min-height: 150px;
            flex-grow: 1;
            padding: 5px 2px; /* Adjusted padding */
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }

        /* --- Task Styling --- */
        .task {
            background-color: var(--color-white);
            padding: 12px 15px;
            margin-bottom: 12px;
            border-radius: 6px;
            cursor: grab;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.07);
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            word-wrap: break-word;
            border-left: 5px solid transparent;
        }

        .task.priority-low { border-left-color: var(--priority-low); }
        .task.priority-medium { border-left-color: var(--priority-medium); }
        .task.priority-high { border-left-color: var(--priority-high); }

        .task-content {
            display: block; /* Changed to block for better layout with timer */
            margin-bottom: 5px; /* Space between text and timer */
            cursor: text;
        }

        .task-timer-display {
            display: block; /* Ensure it takes its own line */
            font-size: 0.85em;
            color: var(--color-timer);
            margin-top: 5px;
            min-height: 1.2em; /* Reserve space even when empty */
        }

        .task-editing input {
            width: 100%;
            padding: 5px;
            border: 1px solid var(--color-primary);
            border-radius: 3px;
            font: inherit;
            box-sizing: border-box;
            margin-bottom: 5px; /* Maintain spacing */
        }

        .task:active { cursor: grabbing; background-color: #f1f3f5; box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1); }

        .task .delete-task {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #adb5bd;
            color: var(--color-white);
            border: none;
            border-radius: 50%;
            width: 22px;
            height: 22px;
            font-size: 14px;
            line-height: 20px;
            text-align: center;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s ease, background-color 0.2s ease;
            z-index: 1; /* Ensure button is above content */
        }

        .task:hover .delete-task { opacity: 1; }
        .task .delete-task:hover { background-color: var(--color-danger); }

        .dragging { opacity: 0.4; transform: rotate(3deg); }
        .drag-over { background-color: #d0ebff; border: 2px dashed var(--color-primary); }

        #todo-column { background-color: #e7f5ff; }
        #inprogress-column { background-color: #fff9db; }
        #done-column { background-color: #e6fcf5; }
        #done-column .task { background-color: #d3f9d8; text-decoration: line-through; opacity: 0.8; }
        #done-column .task .task-content { text-decoration: line-through; } /* Apply strikethrough only to text */

        .clear-done-btn {
            display: block; margin: 15px auto 5px auto; padding: 8px 15px;
            background-color: var(--color-secondary); color: var(--color-text);
            border: none; border-radius: 5px; cursor: pointer; font-size: 0.9rem;
            transition: background-color 0.3s ease, transform 0.1s ease;
        }
        .clear-done-btn:hover { background-color: #3acdab; }
        .clear-done-btn:active { transform: scale(0.98); }

    </style>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
</head>
<body>

    <main class="shell pattern">
      <nav class="nav">
        <a class="brand" href="index.html">
          <span class="brand-dots"><span></span><span></span><span></span><span></span></span>
          <span>Bui Tan Thanh</span>
        </a>
        <div class="nav-links">
          <a href="index.html#projects">Projects</a>
          <a class="btn" href="more-projects.html">More</a>
        </div>
      </nav>

      <h1>Kanban Board with Timers</h1>

      <div class="add-task-form">
        <input type="text" id="new-task-input" placeholder="Enter new task..." aria-label="New task description">
        <select id="priority-select" aria-label="Task priority">
            <option value="low">Low Priority</option>
            <option value="medium" selected>Medium Priority</option>
            <option value="high">High Priority</option>
        </select>
        <button id="add-task-button">Add Task</button>
      </div>

      <div class="kanban-board">
        <div class="column" id="todo-column">
            <div class="column-header">
                <h2>To Do</h2>
                <span class="task-count" id="todo-count">0</span>
            </div>
            <div class="tasks" id="todo-tasks" ondragover="allowDrop(event)" ondrop="drop(event)"></div>
        </div>
        <div class="column" id="inprogress-column">
            <div class="column-header">
                <h2>In Progress</h2>
                <span class="task-count" id="inprogress-count">0</span>
            </div>
            <div class="tasks" id="inprogress-tasks" ondragover="allowDrop(event)" ondrop="drop(event)"></div>
        </div>
        <div class="column" id="done-column">
             <div class="column-header">
                <h2>Done</h2>
                <span class="task-count" id="done-count">0</span>
            </div>
            <div class="tasks" id="done-tasks" ondragover="allowDrop(event)" ondrop="drop(event)"></div>
             <button class="clear-done-btn" id="clear-done-button">Clear All Done Tasks</button>
        </div>
      </div>

      <footer class="footer">© <span id="year"></span> Bui Tan Thanh</footer>
    </main>

    <script>
        const taskInput = document.getElementById('new-task-input');
        const prioritySelect = document.getElementById('priority-select');
        const addTaskButton = document.getElementById('add-task-button');
        const columns = document.querySelectorAll('.column .tasks');
        const clearDoneButton = document.getElementById('clear-done-button');

        let draggedTask = null;
        let tasks = []; // Array holds task objects { id, text, priority, column, startTime, elapsedTime, lastStartTime }

        // --- Time Formatting ---
        function formatElapsedTime(ms) {
            if (!ms || ms <= 0) return ''; // Don't display if 0 or invalid

            let seconds = Math.floor(ms / 1000);
            let minutes = Math.floor(seconds / 60);
            let hours = Math.floor(minutes / 60);

            seconds = seconds % 60;
            minutes = minutes % 60;

            let parts = [];
            if (hours > 0) parts.push(`${hours}h`);
            if (minutes > 0) parts.push(`${minutes}m`);
            if (seconds > 0 || parts.length === 0) parts.push(`${seconds}s`); // Show seconds if <1m or only unit

            return `⏱️ ${parts.join(' ')}`; // Use an icon
        }


        // --- Task Creation & Rendering ---
        function createTaskElement(task) {
            const taskElement = document.createElement('div');
            taskElement.classList.add('task', `priority-${task.priority}`);
            taskElement.setAttribute('draggable', 'true');
            taskElement.setAttribute('id', task.id);

            // Task Content Span (for text editing)
            const contentSpan = document.createElement('span');
            contentSpan.classList.add('task-content');
            contentSpan.textContent = task.text;
            contentSpan.addEventListener('dblclick', () => enableEditing(taskElement, task));
            taskElement.appendChild(contentSpan);

             // Timer Display Span
            const timerSpan = document.createElement('span');
            timerSpan.classList.add('task-timer-display');
            // Display saved time immediately if task is done or has elapsed time
             if (task.column === 'done-tasks' || (task.elapsedTime && task.elapsedTime > 0)) {
                timerSpan.textContent = formatElapsedTime(task.elapsedTime);
             }
             taskElement.appendChild(timerSpan);

            // Delete button
            const deleteButton = document.createElement('button');
            deleteButton.classList.add('delete-task');
            deleteButton.innerHTML = '&times;';
            deleteButton.setAttribute('aria-label', 'Delete task');
            deleteButton.onclick = (event) => {
                event.stopPropagation();
                deleteTask(task.id);
            };
            taskElement.appendChild(deleteButton);

            // Drag and Drop Event Listeners
            taskElement.addEventListener('dragstart', dragStart);
            taskElement.addEventListener('dragend', dragEnd);

            return taskElement;
        }

        // --- Editing Task (Unchanged) ---
        function enableEditing(taskElement, task) {
            const contentSpan = taskElement.querySelector('.task-content');
             const timerSpan = taskElement.querySelector('.task-timer-display'); // Keep reference
            if (!contentSpan || taskElement.classList.contains('task-editing')) return;

            const currentText = task.text;
            taskElement.classList.add('task-editing');

            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentText;

            contentSpan.style.display = 'none';
            // Insert input before the timer span
            taskElement.insertBefore(input, timerSpan);
            input.focus();

            const saveEdit = () => {
                const newText = input.value.trim();
                if (newText && newText !== currentText) {
                    task.text = newText;
                    contentSpan.textContent = newText;
                    saveTasks();
                    console.log(`Task ${task.id} updated.`);
                } else {
                     contentSpan.textContent = currentText;
                }
                input.remove();
                contentSpan.style.display = '';
                taskElement.classList.remove('task-editing');
            };

            input.addEventListener('blur', saveEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    input.blur();
                }
            });
         }

        // --- Add Task ---
        function addTask() {
            const taskText = taskInput.value.trim();
            const taskPriority = prioritySelect.value;
            if (taskText === '') return;

            const newTask = {
                id: 'task-' + Date.now(),
                text: taskText,
                priority: taskPriority,
                column: 'todo-tasks', // Default column
                startTime: null,      // Timestamp when first moved to In Progress
                elapsedTime: 0,       // Total time spent in In Progress (ms)
                lastStartTime: null   // Timestamp when timer was last started/resumed
            };

            tasks.push(newTask);
            const taskElement = createTaskElement(newTask);
            document.getElementById('todo-tasks').appendChild(taskElement);

            taskInput.value = '';
            prioritySelect.value = 'medium';
            updateTaskCounts();
            saveTasks();
        }

        // --- Drag and Drop ---
        function dragStart(event) {
            draggedTask = event.target;
            event.dataTransfer.setData('text/plain', event.target.id);
            setTimeout(() => {
                if (draggedTask) draggedTask.classList.add('dragging');
            }, 0);
        }

        function dragEnd(event) {
             if (draggedTask) {
                draggedTask.classList.remove('dragging');
            }
             columns.forEach(column => column.classList.remove('drag-over'));
            draggedTask = null;
        }

        function allowDrop(event) {
            event.preventDefault();
            const targetColumn = event.target.closest('.tasks');
             if (targetColumn && targetColumn !== draggedTask?.parentElement) {
                 columns.forEach(col => col.classList.remove('drag-over'));
                 targetColumn.classList.add('drag-over');
            }
        }

        document.querySelectorAll('.tasks').forEach(column => {
            column.addEventListener('dragleave', (event) => {
                 const rect = event.currentTarget.getBoundingClientRect();
                 if (event.clientX < rect.left || event.clientX >= rect.right || event.clientY < rect.top || event.clientY >= rect.bottom) {
                    event.currentTarget.classList.remove('drag-over');
                }
            });
        });

        function drop(event) {
            event.preventDefault();
            const targetColumnEl = event.target.closest('.tasks');
            if (!targetColumnEl || !draggedTask) {
                 cleanupDragState();
                 return;
            }

            const taskId = event.dataTransfer.getData('text/plain');
            // Ensure the element being dropped is the one we started dragging
            if (draggedTask.id !== taskId) {
                console.warn("Mismatched task ID during drop.");
                cleanupDragState();
                return;
            }

            const taskElement = draggedTask; // Use the stored element
            const previousColumnId = taskElement.parentElement.id;
            const targetColumnId = targetColumnEl.id;

             // --- Timer Logic ---
             const taskIndex = tasks.findIndex(t => t.id === taskId);
             if (taskIndex > -1) {
                 const task = tasks[taskIndex];
                 const now = Date.now();

                 // Moving OUT OF In Progress
                 if (previousColumnId === 'inprogress-tasks' && targetColumnId !== 'inprogress-tasks') {
                     if (task.lastStartTime) { // Timer was running
                         const delta = now - task.lastStartTime;
                         task.elapsedTime += delta;
                         task.lastStartTime = null; // Pause timer
                         console.log(`Task ${taskId}: Paused timer. Added ${delta}ms. Total: ${task.elapsedTime}ms`);
                     }
                 }

                 // Moving INTO In Progress
                 if (targetColumnId === 'inprogress-tasks' && previousColumnId !== 'inprogress-tasks') {
                     task.lastStartTime = now; // Start/Resume timer
                     if (task.startTime === null) { // First time in progress
                         task.startTime = now;
                     }
                     console.log(`Task ${taskId}: Started/Resumed timer at ${now}`);
                 }

                  // --- Update Timer Display on Drop (especially for 'Done') ---
                 const timerSpan = taskElement.querySelector('.task-timer-display');
                 if (timerSpan) {
                    if (targetColumnId === 'done-tasks') {
                         // Ensure elapsedTime is final if moved directly from In Progress
                        if (previousColumnId === 'inprogress-tasks' && task.lastStartTime) {
                             // Recalculate final time if needed (should have been done above)
                             // task.elapsedTime += (now - task.lastStartTime); // This line is redundant if logic above is correct
                             task.lastStartTime = null; // Ensure it's null
                        }
                         timerSpan.textContent = formatElapsedTime(task.elapsedTime);
                         console.log(`Task ${taskId}: Moved to Done. Final time: ${formatElapsedTime(task.elapsedTime)}`);
                     } else if (targetColumnId !== 'inprogress-tasks' && task.elapsedTime > 0) {
                         // Show accumulated time if moved back to 'To Do' but has time logged
                         timerSpan.textContent = formatElapsedTime(task.elapsedTime);
                     } else if (targetColumnId !== 'inprogress-tasks'){
                         // Clear display if moved to 'To Do' with no time logged yet
                         timerSpan.textContent = '';
                     }
                      // (We are not showing a *live* running timer in In Progress for simplicity)
                 }


                 // Update task's column property *after* timer logic
                 task.column = targetColumnId;

             } else {
                 console.error(`Task data not found for ID: ${taskId} during drop`);
             }
             // --- End Timer Logic ---


            // Move the DOM element
            targetColumnEl.appendChild(taskElement);
            targetColumnEl.classList.remove('drag-over');

            // Trigger confetti only if moving INTO the Done column
            if (targetColumnId === 'done-tasks' && previousColumnId !== 'done-tasks') {
                 triggerConfetti();
             }

            updateTaskCounts();
            saveTasks(); // Save the updated state including timer data
            cleanupDragState();
        }

        function cleanupDragState() {
             if (draggedTask) {
                draggedTask.classList.remove('dragging');
             }
             columns.forEach(col => col.classList.remove('drag-over'));
            draggedTask = null;
        }

        // --- Deletion ---
        function deleteTask(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!confirm(`Are you sure you want to delete task "${task?.text || taskId}"?`)) {
                 return;
            }

            const taskElement = document.getElementById(taskId);
            if (taskElement) {
                taskElement.remove();
                tasks = tasks.filter(t => t.id !== taskId); // Remove from array
                updateTaskCounts();
                saveTasks(); // Update localStorage
                console.log(`Deleted task: ${taskId}`);
            }
        }

        // --- Clear Done Tasks ---
        function clearDoneTasks() {
            const doneTasksContainer = document.getElementById('done-tasks');
            const doneTaskElements = doneTasksContainer.querySelectorAll('.task');
            if (doneTaskElements.length === 0) {
                alert("There are no tasks in the 'Done' column to clear.");
                return;
            }
            if (confirm(`Are you sure you want to clear all ${doneTaskElements.length} tasks from the 'Done' column? This cannot be undone.`)) {
                const doneTaskIds = Array.from(doneTaskElements).map(task => task.id);
                doneTaskElements.forEach(task => task.remove());
                tasks = tasks.filter(task => !doneTaskIds.includes(task.id)); // Filter out
                updateTaskCounts();
                saveTasks();
                console.log("Cleared all tasks from 'Done' column.");
            }
        }

        // --- Task Count Update (Unchanged) ---
        function updateTaskCounts() {
            const counts = { 'todo-tasks': 0, 'inprogress-tasks': 0, 'done-tasks': 0 };
            columns.forEach(column => {
                counts[column.id] = column.getElementsByClassName('task').length;
            });
            document.getElementById('todo-count').textContent = counts['todo-tasks'];
            document.getElementById('inprogress-count').textContent = counts['inprogress-tasks'];
            document.getElementById('done-count').textContent = counts['done-tasks'];
        }

        // --- Confetti (Unchanged) ---
        function triggerConfetti() {
            confetti({ particleCount: 180, spread: 100, origin: { y: 0.6 }, colors: ['#4a90e2', '#50e3c2', '#f5a623', '#ffffff', '#f8f9fa'] });
        }

        // --- Local Storage ---
        function saveTasks() {
            try {
                // Note: We don't save lastStartTime, as timers don't persist across reloads
                 const tasksToSave = tasks.map(t => ({
                    id: t.id,
                    text: t.text,
                    priority: t.priority,
                    column: t.column,
                    startTime: t.startTime,
                    elapsedTime: t.elapsedTime
                 }));
                localStorage.setItem('kanbanTasks_timed', JSON.stringify(tasksToSave));
                console.log("Tasks saved:", tasksToSave.length);
            } catch (e) {
                console.error("Error saving tasks to localStorage:", e);
                alert("Could not save tasks. Local storage might be full or unavailable.");
            }
        }

        function loadTasks() {
            const savedTasks = localStorage.getItem('kanbanTasks_timed');
            tasks = []; // Start with empty array
            if (savedTasks) {
                try {
                    const loadedData = JSON.parse(savedTasks);
                    // Restore tasks, ensuring all needed fields exist
                    tasks = loadedData.map(t => ({
                        ...t, // Spread loaded data
                        priority: t.priority || 'medium', // Default priority if missing
                        startTime: t.startTime || null,
                        elapsedTime: t.elapsedTime || 0,
                        lastStartTime: null // Always null on load
                    }));
                    console.log("Tasks loaded:", tasks.length);

                    columns.forEach(column => column.innerHTML = ''); // Clear columns before rendering

                    tasks.forEach(task => {
                        const taskElement = createTaskElement(task);
                        const columnElement = document.getElementById(task.column);
                        if (columnElement) {
                            columnElement.appendChild(taskElement);
                        } else {
                            console.warn(`Column ${task.column} not found for task ${task.id}, placing in 'To Do'.`);
                            document.getElementById('todo-tasks').appendChild(taskElement);
                            task.column = 'todo-tasks'; // Fix data
                         }
                    });
                    // Optional: Re-save if any tasks were moved to 'To Do'
                    // saveTasks();
                 } catch(e) {
                    console.error("Error parsing tasks from localStorage:", e);
                    localStorage.removeItem('kanbanTasks_timed'); // Clear potentially corrupted data
                    tasks = [];
                 }
            } else {
                console.log("No tasks found in localStorage.");
            }
            updateTaskCounts();
        }

        // --- Event Listeners ---
        addTaskButton.addEventListener('click', addTask);
        taskInput.addEventListener('keypress', function(event) { if (event.key === 'Enter') addTask(); });
        clearDoneButton.addEventListener('click', clearDoneTasks);

        // Load tasks on page load
        document.addEventListener('DOMContentLoaded', () => { loadTasks(); document.getElementById('year').textContent = new Date().getFullYear(); });

    </script>

</body>
</html>
